{% from 'macros/helpers.jinja2' import cpo_type_aliases %}
{% from 'macros/dispatch.jinja2' import typed_operator_overloads %}

[[deprecated("CPO with all concrete types - consider using regular function instead. Intended for experimentation/testing only.")]]
inline constexpr struct {{ cpo_name }}_ftor final : tincup::cpo_base<{{ cpo_name }}_ftor> {
  TINCUP_CPO_TAG("{{ cpo_name }}")
  inline static constexpr bool is_variadic = {{ 'true' if has_variadic else 'false' }};
  // Re-expose base operator() so failures route to diagnostics
  using tincup::cpo_base<{{ cpo_name }}_ftor>::operator();

{{ typed_operator_overloads(cpo_name, "", arg_pairs, arg_names, concept_types, canonical_concept_args) }}
} {{ cpo_name }};

// Note: operator() methods are provided by cpo_base

{{ cpo_type_aliases(cpo_name, "", concept_types, semantic_info, canonical_concept_args) }}

// External generator-provided argument trait specialization for {{ cpo_name }} (concrete)
// NOTE: Replace YOUR_NAMESPACE with the actual namespace containing your CPO
// (e.g., rvf::{{ cpo_name }}_ftor, my_lib::{{ cpo_name }}_ftor, etc.)
namespace tincup {
  template<
    {%- for a in args -%}
    typename _A{{ loop.index0 }}{{ ', ' if not loop.last else '' }}
    {%- endfor -%}
  >
  struct cpo_arg_traits<YOUR_NAMESPACE::{{ cpo_name }}_ftor, 
    {%- for a in args -%}
    {{ a.full }}{{ ', ' if not loop.last else '' }}
    {%- endfor -%}
  > {
    static constexpr bool available = true;
    static constexpr std::size_t fixed_arity = {{ args | length }};
    static constexpr arity_type values_mask = []{
      arity_type m = arity_type{0};
      {% for a in args %}
        {% set full = a.full %}
        {% set has_ref = '&' in full %}
        {% set has_ptr = '*' in full %}
        {% if (not has_ref) and (not has_ptr) %}
      m |= (arity_type{1} << {{ loop.index0 }});
        {% endif %}
      {% endfor %}
      return m;
    }();
    static constexpr arity_type pointers_mask = []{
      arity_type m = arity_type{0};
      {% for a in args %}
        {% if '*' in a.full %}m |= (arity_type{1} << {{ loop.index0 }});{% endif %}
      {% endfor %}
      return m;
    }();
    static constexpr arity_type lvalue_refs_mask = []{
      arity_type m = arity_type{0};
      {% for a in args %}
        {% if ('&' in a.full) and ('&&' not in a.full) %}m |= (arity_type{1} << {{ loop.index0 }});{% endif %}
      {% endfor %}
      return m;
    }();
    static constexpr arity_type rvalue_refs_mask = []{
      arity_type m = arity_type{0};
      {% for a in args %}
        {% if ('&&' in a.full) and (not a.is_forwarding) %}m |= (arity_type{1} << {{ loop.index0 }});{% endif %}
      {% endfor %}
      return m;
    }();
    static constexpr arity_type forwarding_refs_mask = []{
      arity_type m = arity_type{0};
      {% for a in args %}
        {% if ('&&' in a.full) and a.is_forwarding %}m |= (arity_type{1} << {{ loop.index0 }});{% endif %}
      {% endfor %}
      return m;
    }();
    static constexpr arity_type lvalue_const_refs_mask = []{
      arity_type m = arity_type{0};
      {% for a in args %}
        {% if ('&' in a.full) and ('&&' not in a.full) and ('const' in a.full) %}m |= (arity_type{1} << {{ loop.index0 }});{% endif %}
      {% endfor %}
      return m;
    }();
    static constexpr arity_type const_qualified_mask = []{
      arity_type m = arity_type{0};
      {% for a in args %}
        {% if 'const' in a.full %}m |= (arity_type{1} << {{ loop.index0 }});{% endif %}
      {% endfor %}
      return m;
    }();
  };
}
