
{% from 'macros/helpers.jinja2' import cpo_type_aliases %}
{% from 'macros/dispatch.jinja2' import boolean_dispatch, string_dispatch, typed_operator_overloads %}

{%- if is_llm_mode %}
// LLM_TODO: Adjust expected signature if needed - currently: ({{ arg_pairs }})
// LLM_HINT: The operator() calls are inherited from cpo_base via CRTP - no manual implementation needed
{% endif %}
inline constexpr struct {{ cpo_name }}_ftor final : tincup::cpo_base<{{ cpo_name }}_ftor> {
  TINCUP_CPO_TAG("{{ cpo_name }}")
  inline static constexpr bool is_variadic = {{ 'true' if has_variadic else 'false' }};
  // Re-expose base operator() so failures route to diagnostics
  using tincup::cpo_base<{{ cpo_name }}_ftor>::operator();
{%- if dispatch_info and dispatch_info.type == 'bool' %}
  {{ boolean_dispatch(cpo_name, dispatch_info, arg_types, arg_pairs, arg_names, concept_types, arg_pairs_no_dispatch, arg_names_no_dispatch, concept_types_no_dispatch) }}
{%- elif dispatch_info and dispatch_info.type == 'string' %}
  {{ string_dispatch(cpo_name, dispatch_info, arg_types, arg_pairs, arg_names, concept_types, arg_pairs_no_dispatch, arg_names_no_dispatch, concept_types_no_dispatch) }}
{%- else %}

  {{ typed_operator_overloads(cpo_name, arg_types, arg_pairs, arg_names, concept_types, canonical_concept_args) }}
{%- endif %}

} {{ cpo_name }};

// Note: operator() methods are provided by cpo_base

{{ cpo_type_aliases(cpo_name, arg_types, concept_types, semantic_info, canonical_concept_args) }}

// External generator-provided argument trait specialization for {{ cpo_name }}
// Forward declare primary template to allow specialization even if not included yet
namespace tincup { template<typename Cp, typename...Args> struct cpo_arg_traits; }

namespace tincup {
  template<{{ arg_types }}>
  struct cpo_arg_traits<{{ cpo_name }}_ftor, {{ concept_types }}> {
    static constexpr bool available = true;
    // Fixed (non-pack) argument count
    static constexpr std::size_t fixed_arity = {{ args | selectattr('is_variadic', 'equalto', False) | list | length }};

    // Helpers to build repeated masks for parameter packs
    static constexpr arity_type repeat_mask(std::size_t offset, std::size_t count) {
      arity_type m = arity_type{0};
      for (std::size_t i = 0; i < count; ++i) m |= (arity_type{1} << (offset + i));
      return m;
    }

    // Values mask
    static constexpr arity_type values_mask = []{
      arity_type m = arity_type{0};
      // Fixed positions
      {% for a in args %}
        {% if not a.is_variadic %}
          {% set full = a.full %}
          {% set has_ref = '&' in full %}
          {% set has_ptr = '*' in full %}
          {% if (not has_ref) and (not has_ptr) %}
      m |= (arity_type{1} << {{ loop.index0 }});
          {% endif %}
        {% endif %}
      {% endfor %}
      // Pack positions
      {% set pack = (args | selectattr('is_variadic') | list | first if has_variadic else None) %}
      {% if has_variadic and pack %}
        // For packs, category is determined by the declared form of the pack
        {% set pfull = pack.full %}
        {% set p_has_ref = '&' in pfull %}
        {% set p_has_rref = '&&' in pfull %}
        {% set p_has_ptr = '*' in pfull %}
        {% if (not p_has_ref) and (not p_has_ptr) %}
      m |= repeat_mask(fixed_arity, sizeof...({{ pack.base }}));
        {% endif %}
      {% endif %}
      return m;
    }();

    // Pointers mask
    static constexpr arity_type pointers_mask = []{
      arity_type m = arity_type{0};
      {% for a in args %}
        {% if not a.is_variadic %}
          {% if '*' in a.full %}m |= (arity_type{1} << {{ loop.index0 }});{% endif %}
        {% endif %}
      {% endfor %}
      {% if has_variadic and pack and ('*' in pack.full) %}
      m |= repeat_mask(fixed_arity, sizeof...({{ pack.base }}));
      {% endif %}
      return m;
    }();

    // Lvalue refs mask
    static constexpr arity_type lvalue_refs_mask = []{
      arity_type m = arity_type{0};
      {% for a in args %}
        {% if not a.is_variadic %}
          {% if ('&' in a.full) and ('&&' not in a.full) %}m |= (arity_type{1} << {{ loop.index0 }});{% endif %}
        {% endif %}
      {% endfor %}
      {% if has_variadic and pack and (('&' in pack.full) and ('&&' not in pack.full)) %}
      m |= repeat_mask(fixed_arity, sizeof...({{ pack.base }}));
      {% endif %}
      return m;
    }();

    // Rvalue refs mask (non-forwarding)
    static constexpr arity_type rvalue_refs_mask = []{
      arity_type m = arity_type{0};
      {% for a in args %}
        {% if not a.is_variadic %}
          {% if ('&&' in a.full) %}m |= (arity_type{1} << {{ loop.index0 }});{% endif %}
        {% endif %}
      {% endfor %}
      {% if has_variadic and pack and ('&&' in pack.full) and (not pack.is_forwarding) %}
      m |= repeat_mask(fixed_arity, sizeof...({{ pack.base }}));
      {% endif %}
      return m;
    }();

    // Forwarding refs mask
    static constexpr arity_type forwarding_refs_mask = []{
      arity_type m = arity_type{0};
      {% for a in args %}
        {% if not a.is_variadic %}
          {% if ('&&' in a.full) and a.is_forwarding %}m |= (arity_type{1} << {{ loop.index0 }});{% endif %}
        {% endif %}
      {% endfor %}
      {% if has_variadic and pack and ('&&' in pack.full) and pack.is_forwarding %}
      m |= repeat_mask(fixed_arity, sizeof...({{ pack.base }}));
      {% endif %}
      return m;
    }();

    // Lvalue const refs mask
    static constexpr arity_type lvalue_const_refs_mask = []{
      arity_type m = arity_type{0};
      {% for a in args %}
        {% if not a.is_variadic %}
          {% if ('&' in a.full) and ('&&' not in a.full) and ('const' in a.full) %}m |= (arity_type{1} << {{ loop.index0 }});{% endif %}
        {% endif %}
      {% endfor %}
      {% if has_variadic and pack and (('&' in pack.full) and ('&&' not in pack.full) and ('const' in pack.full)) %}
      m |= repeat_mask(fixed_arity, sizeof...({{ pack.base }}));
      {% endif %}
      return m;
    }();

    // Const-qualified mask (applies to values, refs, or pointers where declared const)
    static constexpr arity_type const_qualified_mask = []{
      arity_type m = arity_type{0};
      {% for a in args %}
        {% if not a.is_variadic %}
          {% if 'const' in a.full %}m |= (arity_type{1} << {{ loop.index0 }});{% endif %}
        {% endif %}
      {% endfor %}
      {% if has_variadic and pack and ('const' in pack.full) %}
      m |= repeat_mask(fixed_arity, sizeof...({{ pack.base }}));
      {% endif %}
      return m;
    }();
  };
}
