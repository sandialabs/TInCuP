#!/usr/bin/env python3
# TInCuP - A library for generating and validating C++ customization point objects that use `tag_invoke`
#
# Copyright (c) National Technology & Engineering Solutions of Sandia,
# LLC (NTESS). Under the terms of Contract DE-NA0003525 with NTESS, the U.S.
# Government retains certain rights in this software.
#
# Questions? Contact Greg von Winckel (gvonwin@sandia.gov)


import subprocess
import sys
import re
import tempfile
from pathlib import Path
from typing import Set, List

def run_quom(input_file: Path, output_file: Path) -> bool:
    """Run quom to generate a single header file."""
    try:
        result = subprocess.run([
            'quom', str(input_file), str(output_file)
        ], capture_output=True, text=True, check=True)
        print(f"Successfully generated single header with quom")
        return True
    except subprocess.CalledProcessError as e:
        print(f"Error running quom: {e}")
        print(f"stdout: {e.stdout}")
        print(f"stderr: {e.stderr}")
        return False
    except FileNotFoundError:
        print("Error: quom not found. Please install quom first.")
        return False

def get_banner_text() -> str:
    """Get the banner text from banner_check.py."""
    return (
        "TInCuP - A library for generating and validating C++ customization point objects that use `tag_invoke`\n\n"
        "Copyright (c) National Technology & Engineering Solutions of Sandia, \n"
        "LLC (NTESS). Under the terms of Contract DE-NA0003525 with NTESS, the U.S. \n"
        "Government retains certain rights in this software.\n\n"
        "Questions? Contact Greg von Winckel (gvonwin@sandia.gov)\n"
    ).strip()

def remove_existing_banners(content: str) -> str:
    """Remove all existing copyright banner blocks from the content."""
    banner_text = get_banner_text()
    escaped_banner = re.escape(banner_text)
    
    # Remove C++ style banner blocks
    cpp_pattern = rf'/\*\*\s*{escaped_banner}\s*\*/'
    content = re.sub(cpp_pattern, '', content, flags=re.DOTALL)
    
    # Remove any standalone /** */ blocks that might be leftover
    content = re.sub(r'/\*\*\s*\*/', '', content, flags=re.DOTALL)
    
    return content

def extract_system_includes(content: str) -> Set[str]:
    """Extract all system includes (< >) from the content."""
    system_includes = set()
    
    # Find all #include <...> statements
    include_pattern = r'#include\s+<([^>]+)>'
    matches = re.findall(include_pattern, content)
    
    for match in matches:
        system_includes.add(match)
    
    return system_includes

def remove_system_includes(content: str) -> str:
    """Remove all #include <...> statements from content."""
    # Remove system includes
    content = re.sub(r'#include\s+<[^>]+>\s*\n?', '', content)
    return content

def create_banner_block() -> str:
    """Create the C++ banner block."""
    banner_text = get_banner_text()
    return f"/**\n{banner_text}\n*/\n\n"

def organize_includes(system_includes: Set[str]) -> str:
    """Create organized include block."""
    if not system_includes:
        return ""
    
    # Sort alphabetically
    sorted_includes = sorted(system_includes)
    
    # Create include statements
    include_lines = [f"#include <{inc}>" for inc in sorted_includes]
    
    return "\n".join(include_lines) + "\n\n"

def process_single_header(input_file: Path, output_file: Path) -> bool:
    """Process the single header file generated by quom."""
    try:
        # Read the generated content
        with open(input_file, 'r', encoding='utf-8') as f:
            content = f.read()
        
        print("Processing single header file...")
        
        # Step 1: Remove existing banners
        content = remove_existing_banners(content)
        
        # Step 2: Extract system includes
        system_includes = extract_system_includes(content)
        print(f"Found {len(system_includes)} unique system includes")
        
        # Step 3: Remove system includes from content
        content = remove_system_includes(content)
        
        # Step 4: Find #pragma once
        pragma_match = re.search(r'#pragma once', content)
        if not pragma_match:
            print("Warning: No #pragma once found in file")
            pragma_pos = 0
        else:
            pragma_pos = pragma_match.end()
        
        # Step 5: Build the new content
        banner_block = create_banner_block()
        pragma_line = "#pragma once\n\n"
        includes_block = organize_includes(system_includes)
        
        # Find content after pragma once (skip any whitespace)
        remaining_content = content[pragma_pos:].lstrip()
        
        # Combine everything
        new_content = banner_block + pragma_line + includes_block + remaining_content
        
        # Step 6: Write the processed file
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write(new_content)
        
        print(f"Successfully processed single header: {output_file}")
        return True
        
    except Exception as e:
        print(f"Error processing single header: {e}")
        return False

def main():
    """Main function to generate and process single header."""
    # Get the parent directory (project root) when running from scripts/
    project_root = Path(__file__).parent.parent
    
    # Default output location following nlohmann::json style
    default_output = project_root / "single_include" / "tincup.hpp"
    
    if len(sys.argv) == 1:
        # No arguments - use default location
        output_file = default_output
    elif len(sys.argv) == 2:
        # Single argument - use as output file
        output_file = Path(sys.argv[1])
        if not output_file.is_absolute():
            output_file = project_root / output_file
    else:
        print("Usage: python generate_single_header.py [output_file]")
        print("  If no output_file is specified, defaults to single_include/tincup.hpp")
        sys.exit(1)
    
    input_dir = project_root / "include/tincup"
    main_header = input_dir / "tincup.hpp"
    
    if not main_header.exists():
        print(f"Error: Main header file not found: {main_header}")
        sys.exit(1)
    
    print(f"Generating single header from {main_header} to {output_file}")
    
    # Step 1: Use quom to generate single header in temporary file
    with tempfile.NamedTemporaryFile(mode='w', suffix='.hpp', delete=False) as temp_file:
        temp_path = Path(temp_file.name)
    
    try:
        if not run_quom(main_header, temp_path):
            sys.exit(1)
        
        # Step 2: Process the generated header
        if not process_single_header(temp_path, output_file):
            sys.exit(1)
        
        print("Single header generation completed successfully!")
        
    finally:
        # Clean up temporary file
        temp_path.unlink(missing_ok=True)

if __name__ == "__main__":
    main()